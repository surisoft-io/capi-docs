{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to CAPI Gateway Documentation","text":""},{"location":"#what-is-capi-gateway","title":"What is CAPI Gateway","text":"<p>CAPI, like any other API gateway, sits between a client and a collection of services.</p> <p>CAPI supports features such as: routing, user authentication, throttling, limiting, policies, error handling, load balancing, failover and statistics.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Light API Gateway powered by Apache Camel dynamics routes.</li> <li>Support for Multiple Oauth2 providers. </li> <li>Support for Open Policy Agent Rego (<code>raygo</code>)</li> <li>Websocket support</li> <li>Distributed tracing system (Open Telemetry Collector / Zipkin)</li> <li>Metrics (Prometheus)</li> <li>Load Balancer (Round robin)</li> <li>Reverse Proxy</li> <li>Failover (With and without Round Robin)</li> <li>Multi Tenant support</li> <li>Stick Session (Cookies and Headers)</li> <li>Certificate Manager (using the CAPI Metrics API)</li> <li>Supports Hashicorp Consul for service discovery</li> <li>Supports Hashicorp Consul KV Store for distributed runtime key values.</li> </ul> <p>Let us know if you find any issue with the documentation</p>"},{"location":"config/","title":"How CAPI is configured?","text":"<p>By default CAPI uses Hashicorp Consul to discover services, and all the services returned by Consul's catalog API will be available on CAPI.</p>"},{"location":"config/#namespace-configuration","title":"Namespace Configuration","text":"<p>You can give a namespace to CAPI, with 2 possible options:</p>"},{"location":"config/#option-1-permissive","title":"Option 1: Permissive","text":"<pre><code>capi:\n  namespace: demo\n  strict: false\n</code></pre> <p>With a name space in permissive mode, CAPI will create routes for every services discovered on Consul, except those with a different namespace in its metadata More about Metadata here...</p>"},{"location":"config/#option-2-strict","title":"Option 2: Strict","text":"<p><pre><code>capi:\n  namespace: demo\n  strict: true\n</code></pre> With a name space in strict mode, CAPI will create routes for services discovered with the Metadata namespace set to <code>demo</code>. </p>"},{"location":"config/#capi-exposes-by-default-the-following-ports","title":"CAPI exposes by default the following ports:","text":"<ul> <li>8380 - Route Port: This is the main port, where your services will be exposed.</li> <li>8381 - Metric Port: Where all the metrics (actuators) are available, includes by default: Prometheus, Health, Routes, Info (General info about CAPI runtime), Certicate Management (Trustore), Open API explorer.</li> <li>8382 - Websocket Port (if enabled).</li> <li>8383 - gRPC Port (if enabled / experimental).</li> <li>8389 - Error Port, all errors are forwarded to this endpoint.</li> </ul>"},{"location":"config/#traces-integration-are-optional-so-if-you-need-make-sure-to-enable-it","title":"Traces integration are optional, so if you need, make sure to enable it.","text":"<p>Integrations supported: * Zipkin * Jaeger * Open Telemetry Collector (otel)</p>"},{"location":"config/#how-to-enable","title":"How to enable:","text":"<pre><code>capi:\n traces:\n   enabled: true\n   endpoint: http://localhost:9411/api/v2/spans\n</code></pre>"},{"location":"config/#capi-discovers-your-services-using-consul-in-this-example-capi-will-check-for-newchanges-on-consul-every-20-seconds","title":"CAPI discovers your Services using Consul. (in this example, CAPI will check for new/changes on Consul every 20 seconds)","text":""},{"location":"config/#capi-can-also-use-consul-key-store-for-storing-run-time-info-like-cors-headers","title":"CAPI can also use Consul Key Store for storing run time info, like CORS headers","text":"<pre><code>capi:\n consul:\n  kv:\n    enabled: false\n    timer:\n      interval: 20000\n  token:\n  hosts: http://localhost:8500\n    discovery:\n      enabled: true\n      timer:\n        interval: 20000\n</code></pre>"},{"location":"config/#capi-can-have-its-own-certificate-trust-store-and-not-use-the-jvm-default-if-you-want-you-need-to-enable-it","title":"CAPI can have its own Certificate Trust Store and not use the JVM default. If you want, you need to enable it:","text":"<pre><code>capi:\n  trust:\n    store:\n      enabled: true\n      path: /your/cacerts/path\n      password: changeit\n</code></pre>"},{"location":"config/#capi-management-endpoint-runs-on-dedicated-port-default-8381","title":"CAPI management endpoint runs on dedicated port (default <code>8381</code>):","text":"<pre><code>management:\n  server:\n    port: 8381\n  security:\n    enabled: false\n  endpoint:\n    camelroutes:\n      enabled: true\n  endpoints:\n    web:\n      base-path: /metrics/\n      exposure:\n        include: 'health,prometheus,routes,capi'\n</code></pre> <p>It is important to expose the <code>routes</code> and <code>capi</code> endpoints, since they provide important information about the run time. </p>"},{"location":"config/#capi-uses-apache-camel-for-the-routing-mechanism","title":"CAPI uses Apache Camel for the routing mechanism.","text":""},{"location":"config/#the-c-of-capi-actually-stands-camel","title":"The \"C\" of CAPI actually stands Camel","text":"<p>By default the route context is exposed on /capi, but you can change it: <pre><code>camel:\n  servlet:\n    mapping:\n      context-path: /capi/*\n</code></pre></p>"},{"location":"config/#opa-configuration","title":"OPA Configuration","text":"<p>By default, OPA is disabled, to enable change the following properties: <pre><code>capi:\n  opa:\n    enabled: true\n    endpoint: http://localhost:8181\n</code></pre> For more information about OPA on CAPI, go Here...</p>"},{"location":"config/#oauth2-configuration","title":"OAUTH2 Configuration","text":"<p>By default, oauth2 is disabled, to enable change the following properties: <pre><code>capi:\n  oauth2:\n    cookieName:\n    provider:\n      enabled: false\n      keys:\n        - http://localhost:8080/realms/realm1/protocol/openid-connect/certs\n        - http://localhost:8080/realms/realm2/protocol/openid-connect/certs\n</code></pre> For more information about oauth2 on CAPI, go Here...</p>"},{"location":"consul/","title":"Consul Integration","text":""},{"location":"consul/#how-to-make-your-service-discovered-by-consul-and-capi","title":"How to make your service discovered by Consul and CAPI?","text":"<p>CAPI integrates with Hashicorp Consul (see Configuration, to find how to enable). The following example uses a dummy service implemented with Spring Boot.</p> <p>There are many strategies of making your service to be discovered by Consul, but for simplicity we will just mention 2: * Install Hashicorp Consul agent on your Kubernetes cluster: (https://developer.hashicorp.com/consul/docs/k8s) * Enable Consul auto discovery on your Spring Boot project. </p>"},{"location":"consul/#lets-use-the-second-for-our-example","title":"Let's use the second for our example","text":"<p>Make sure to include the following dependencies in your project: <pre><code>&lt;dependency&gt;\n  &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n  &lt;artifactId&gt;spring-cloud-starter-consul&lt;/artifactId&gt;\n  &lt;version&gt;4.0.2&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n  &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n  &lt;artifactId&gt;spring-cloud-starter-consul-discovery&lt;/artifactId&gt;\n  &lt;version&gt;4.0.2&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre></p> <p>Now that Consul is enabled, you will need to tell Consul about your service, using your application file: <pre><code>server\n  port: 8080\nspring:\n  application:\n    name: dummy\n  cloud:\n    consul:\n      enabled: true\n      port: 8500\n      host: http://localhost\n      discovery:\n        instance-id: dummy-localhost-${server.port}\n        instance-group: dev\n        scheme: http\n        hostname: localhost\n        port: ${server.port}\n        tags: Owner=Your name, emailid=mail@domain.com\n        metadata:\n          group: dev\n        health-check-url: http://localhost:${server.port}/actuator/health\n</code></pre> As soon your service is running, will self register on Consul, and it should now be visible by CAPI.</p> <p>If CAPI is running with the default configuration on your localhost, you should now be able to call your service using CAPI, like this: <pre><code>curl http://localhost:8380/capi/dummy/dev/actuator/health\n</code></pre></p> <p>If you then scale up your service by having another instance running on 8081, that instance will also self register on Consul and it will be added as a new node in the \"dummy\" service. </p> <p>CAPI will then detect this change and add the new node to the routing mechanism. </p> <p>After you will be able to observe CAPI load balancing between your 2 nodes.</p>"},{"location":"consul/#important-metadata-info-for-capi","title":"Important Metadata info for CAPI","text":"<p>CAPI will always check the Consul's metadata <code>metadata:</code> to figure out how to deploy a service.</p> <p>The only mandatory field in the metadata is the group (<code>group</code>). </p> <p>CAPI will use this field to determine your context.</p> <p>Example for a service called <code>test-service</code>:</p> <p><pre><code>metadata:\n  group: prod\n</code></pre> If this example your service will be exposed on <code>/capi/test-service/prod/</code>.</p> <p>Here are optional metadata info that your service can send to Consul.</p> <ul> <li><code>schema</code>: If your service is exposed on HTTPS, declare this field as: https. (Default: HTTP)</li> <li><code>secured</code>: If you want CAPI to protect your service ( See oauth2 integration), declare this field with true) (Default: false)</li> <li> <p><code>subscription-group</code>: If CAPI is proctecting your service, you may want to declare which subscribers are allowed to consume your service. Example: <pre><code>metadata:\n  secured: true\n  subscription-group: webapp1, webapp2\n</code></pre> In this example only JWT tokens with one of <code>webapp1</code> or <code>webapp2</code> in the subscription claim will be able to consume your service.</p> </li> <li> <p><code>type</code>: If your service is a Websocket, declare this field as websocket, and CAPI will make your websocket available.  See Websocket Support).</p> </li> <li> <p><code>keep-group</code>: By default, CAPI will not forward any headers related with CAPI itself, but if you need your service to know the context where your service is exposed, you can use this metadata property for CAPI to send the information on a header. Example: Service <code>/capi/test-service/production</code>: <pre><code>metadata:\n  keep-group: true\n</code></pre></p> </li> </ul> <p>CAPI will forward the request to your service, with an extra-header:  <code>capi-group: /test-service/production</code>.</p> <ul> <li> <p><code>root-context</code>: By default, CAPI will forward all the requests to the root context of your service. If your service is listening on a specific context you need to provide this metadata info to CAPI.  Example: If your service is listening on: <code>http://some-node:8080/my-context</code>.  <pre><code>metadata:\n root-context: /my-context\n</code></pre>  Every request to CAPI on <code>/capi/test-service/production/getCustomer?ID=1</code> will be forwarded to <code>http://some-node:8080/my-context/getCustomer?ID=1</code></p> </li> <li> <p><code>allowed-origins</code>: If you started CAPI with CORS Support (See <code>Configuration</code>), you can define which origins are allowed to consume your service.  Example:  <pre><code>metadata:\n allowed-origins: http://localhost, http:domain.com \n</code></pre>  If you don't define any allowed origins, CAPI will allow the OPTIONS request for any Origin.</p> </li> </ul> <p>For a complete list of available <code>metadata</code> go to Metadata Integration.</p> <p>## Consul Key Value Store</p> <p>CAPI can use Consul KV API to store distributed runtime data.</p> <p>#### Currently supported features:</p> <ul> <li>CORS Allowed Headers: CAPI instance always starts with a default set of allowed headers (used by browser preflight requests). If you want to be able to add/remove allowed headers at runtime without having to restart your instances you can use the Metrics endpoint to manage the headers, they will be added to Consul KV Store and updated on all CAPI running nodes.</li> </ul>"},{"location":"consul/#features-in-the-roadmap-to-be-supported","title":"Features in the roadmap to be supported:","text":"<ul> <li>Truststore updates</li> <li>Sticky sessions alternative to Kafka.</li> </ul>"},{"location":"meta/","title":"Metadata","text":"<p>Service Metadata is the heart of any service exposed by CAPI. Since CAPI doesn't provide any API for service deployment, it relies interely on the service metadata registered on Consul. (See Consul Integration)</p> <p>Its ence the responsability of the service operations to tell CAPI how they want their service to be exposed. Here you have a full list of all the metadata available:</p> Property Mandatory Default value Description <code>root-context</code> null If provided, CAPI will forward all requests to the given context <code>schema</code> http If your service is listening on HTTP, you need to put <code>schema: https</code> <code>secured</code> false Enable global authorization. Details... <code>group</code> - Mandatory Details... <code>ingress</code> null If defined CAPI will forward the traffic to the specified ingress Details... <code>type</code> rest If null, CAPI assumes you are exposing a rest service. The other option is: <code>type: websocket</code> <code>subscription-group</code> null See OAuth2... <code>allowed-origins</code> null <code>keep-group</code> false <code>open-api</code> null <code>opa-rego</code> null <code>namespace</code> null <code>keep-group-first</code> false Note <p>Below you can find a detailed description about all the metadata fields available. If you are not using Spring Boot (the examples used in the documentation), please refer to Hashicorp Consul API, to check how to register your service. In the Consul catalog, the metadata needs to apper like the example below: <pre><code>\"ServiceMeta\": {\n    \"group\": \"dev\",\n    \"ingress\": \"http://sample.dev\",\n\n}\n</code></pre></p>"},{"location":"meta/#secured","title":"Secured","text":"<p>If <code>secured: true</code> CAPI will enable authorization for all the operations on your service. If you are using Open API to define the security of your operations, CAPI will ignore them and protected even the operations that you declared as open to anonymous calls. If you want CAPI to honor your Open API security definition ignore this field or put it as false. (Check Open-API)  </p>"},{"location":"meta/#group","title":"Group","text":"<p>Group metadata is mandatory because it will define how your Service is exposed on CAPI. Imagine you have a service running on Spring Boot, called <code>sample</code>.  For the same service you may have multiple environments.</p> <p>Imagine you are running the sample service on <code>dev</code> and <code>test</code>:</p> <p>Dev instance will register on Consul with the following metadata: <pre><code>spring:\n  application:\n    name: sample\n  cloud:\n    consul:\n      discovery:\n        metadata:\n          group: dev\n</code></pre> CAPI will expose your service on: <code>http://localhost:8380/capi/sample/dev</code></p>"},{"location":"meta/#ingress","title":"Ingress","text":"<p>CAPI uses Consul Catalog to discover and expose services. If you don't specify an ingress, CAPI will try to forward requests to your service based on consul ServiceAddress and ServicePort. Imagine your service is exposed on HTTP 192.168.2.2 on port 8080.  If no ingress provided, CAPI will try to forward all the requests to http://192.168.2.2:8080. <pre><code>spring:\n  application:\n    name: sample\n  cloud:\n    consul:\n      discovery:\n        metadata:\n          group: dev\n          ingress: http://mysample.dev\n</code></pre> With the following configuration, CAPI will ignore the IP in the ServiceAddress and ServicePort, and use the endpoint defined in the ingress.</p>"},{"location":"meta/#open-api","title":"Open-API","text":"<p>If you want CAPI to only allow valid requests for your service, you need to provide your open api endpoint.</p> <p>CAPI will read your service definition, and will only allow requests to existing operations.</p> <p>CAPI will also check for authorization if any of your operations defines a security requirement. <pre><code>spring:\n  application:\n    name: sample\n  cloud:\n    consul:\n      discovery:\n        metadata:\n          open-api: http://local/sample/v3/api-docs\n</code></pre></p>"},{"location":"meta/#keep-group-first","title":"Keep Group First","text":"<p>By default, when CAPI is reading your service definition, it will take the service name (sample) and your metadata.group (dev) to create the route for your service, your service will then be exposed in the following fashion:</p> <p><code>http://local:8380/capi/sample/dev</code></p> <p>If you want the route to be created with the group first, you can enable this:</p> <p><pre><code>spring:\n  application:\n    name: sample\n  cloud:\n    consul:\n      discovery:\n        metadata:\n          group: dev\n          keep-group-first: true\n</code></pre> If enable your service will be exposed in the following fashion</p> <p><code>http://local:8380/capi/dev/sample</code></p>"},{"location":"oauth2/","title":"oauth2 Integration","text":"<p>There are 2 ways to work with Authorization on CAPI.</p> <p>Here we will talk about simple token validation.</p> <ul> <li>You have control on your oauth2 provider/s, and you are able to manage your token claims, so they can be interpreted by CAPI. In this case you only need to provide CAPI with the Public Keys endpoint of your oauth2 providers (CAPI supports multiple providers) using the property <code>oauth2.provider.keys</code>.</li> </ul> <pre><code>#example\noauth2:\n  provider:\n    enabled: true\n    keys:\n      - http://localhost:8080/realms/realm1/protocol/openid-connect/certs\n      - http://localhost:8080/realms/realm2/protocol/openid-connect/certs\n</code></pre> <p>CAPI works by looking for the <code>subscriptions</code> JWT Token Claim, so you will need to make sure that you can add this custom claim to your authorization provider. </p>"},{"location":"oauth2/#after-having-authorization-enabled-and-if-your-service-is-protected-capi-will-only-route-traffic-to-your-service-if-the-following-conditions-are-met","title":"After having Authorization enabled, and if your service is protected, CAPI will only route traffic to your service if the following conditions are met:","text":"<ul> <li>The token was signed by the oauth2 provider configured: <code>oauth2.provider.keys</code>.</li> <li>The token is not expired.</li> <li>The token azp (authorized party) has a group in the <code>subscriptions</code> clain that matchs one the subscription groups in your service metadata (Check Metadata).</li> </ul> <p>Example for a service called <code>sample</code>, available on <code>/capi/sample/dev</code> with a <code>subscription-group</code> called <code>webapp1</code>:</p> <pre><code>{\n  \"exp\": 1695022079,\n  \"iat\": 1695022019,\n  \"iss\": \"http://localhost:8080/realms/master\",\n  \"azp\": \"example-client\",\n  \"subscriptions\": [\n    \"/webapp1\"\n  ],\n  \"client_id\": \"example-client\"\n}\n</code></pre>"},{"location":"oauth2/#to-resume","title":"To resume","text":"<p>If you want CAPI to perform authorization before routing the traffic to your Service, you will have to do the following: * Enable CAPI Authorization (Check Config). * Declare your Service as protected (<code>Service.serviceMeta.secured</code>) (This is performed during route creation) * When you declare your Service, you can specify a list of groups (<code>subscription-group</code>) allowed to consume your api. (<code>Service.serviceMeta.subscriptionGroup</code>)</p>"},{"location":"opa/","title":"Open Policy Agent","text":""},{"location":"opa/#opa-authorization-rest-and-websocket","title":"OPA Authorization (REST and Websocket)","text":"<p>OPA is a Policy-based control for cloud native environments. For more information about OPA: https://www.openpolicyagent.org/</p> <p>CAPI uses OPA Policies.</p> <p>OPA policies are expressed in a high-level declarative language called Rego. Rego (pronounced \u201cray-go\u201d) is purpose-built for expressing policies over complex hierarchical data structures. For detailed information on Rego see the Policy Language documentation.</p> <p>You can provide your own OPA instance or use our helm charts. CAPI only needs to be able to access OPA API's.</p> <p>To start CAPI with support for OPA, please make sure to provide the following environment properties:</p> <pre><code>opa\n  enabled: true\n  endpoint: http://localhost:8181\n</code></pre> <p>Imagine the following scenario:</p>"},{"location":"opa/#you-want-capi-to-only-allow-traffic-to-your-service-if-the-following-conditions-are-met","title":"You want CAPI to only allow traffic to your service if the following conditions are met:","text":"<ul> <li>Token signed by a spefic key provided by you.</li> <li>Token not expired.</li> <li>The authorized party whith a list that you control.</li> </ul> <p>For these requirements lets design the following REGO. <pre><code>package capi.test.dev\n\nimport future.keywords.if\nimport future.keywords.in\n\ndefault allow := false\n\njwks := `{\n    \"keys\": [\n        {\n        \"kty\": \"RSA\",\n        \"e\": \"AQAB\",\n        \"use\": \"sig\",\n        \"kid\": \"test\",\n        \"alg\": \"RS256\",\n        \"n\": \"zYF3UBCfWxTKzkK..........\"\n        }\n    ]\n}`\n\nclients := [\"my-azp\" ]\n\ncurrent_time = time.now_ns() / 1000000000\n\nallow if {\n    clients[_] = claims.azp\n    current_time &lt; claims.exp\n}\n\nclaims := payload if {\n    io.jwt.verify_rs256(input.token, jwks)\n    [_, payload, _] := io.jwt.decode(input.token)\n}\n</code></pre></p> <p>After creating this REGO you will need to publish on OPA:</p> <pre><code>curl --request PUT \\\n  --url http://localhost:8181/v1/policies/capi/test/dev \\\n  --data 'package capi.eu_search.dev\n\nimport future.keywords.if\nimport future.keywords.in\n\ndefault allow := false\n\njwks := `{\n    \"keys\": [\n        {\n        \"kty\": \"RSA\",\n        \"e\": \"AQAB\",\n        \"use\": \"sig\",\n        \"kid\": \"eucommission\",\n        \"alg\": \"RS256\",\n        \"n\": \"zYF3UBCfWxTKzkK-CTK--y98RFwa2uXUFXOZAr35AJ-nzfDUvEM8RaoSqFofCSjzWLvd9OWuAGv59jOgE_uLVqZjr52hs32w9YLjL6vct7lh264omqxfpblsIp-yEug8rYNYdfwyM-AR-htkurjMSTK7NmeKODlekwItv1E4u5VfSr3hf8SIq0SbqDjnaW7yrWn0N9p6B37UkPV_Cahrn5_5kPYqHm_zSaghviqQh_RjaH2B0yRSaRKzDZf4VjtlXgrd3AoWxwrkmcKDWy0_nQhlcK2zTNCuu0stInbtJ79EFUKJkAOUhuoZGHuivnXDVGssZpTzNPe54-ajWthEqw\"\n        }\n    ]\n}`\n\nclients := [\"pAf3YdVriLyTR5r84dvMGL0Cc8Ua\" ]\n\ncurrent_time = time.now_ns() / 1000000000\n\nallow if {\n    clients[_] = claims.azp\n    current_time &lt; claims.exp\n}\n\nclaims := payload if {\n    io.jwt.verify_rs256(input.token, jwks)\n    [_, payload, _] := io.jwt.decode(input.token)\n}'\n</code></pre> <p>You should be ready to protect your service using OPA. As always, you will need to register your service on Consul, so CAPI can discover.  Here is a sample metadata for your service (Spring Boot using Consul Starter).</p> <pre><code>spring:\n  application:\n    name: test\n  cloud:\n    consul:\n      enabled: true\n      port: 8500\n      host: http://localhost\n      discovery:\n        instance-id: ${info.app.environment}-localhost-${server.port}\n        instance-group: ${info.app.environment}\n        scheme: http\n        hostname: localhost\n        port: 8080\n        metadata:\n          group: dev\n          secured: true\n          opa-rego: capi/test/dev\n        health-check-url: http://localhost:${server.port}/actuator/health\n</code></pre>"},{"location":"properties/","title":"Properties","text":""},{"location":"properties/#capi-property-list","title":"CAPI property list","text":"<pre><code>capi:\n  namespace: local\n  mode: full\n  strict: false\n  public-endpoint: http://localhost:8380/capi/\n\n  reverse:\n    proxy:\n      enabled: false\n      host: localhost:8380\n\n  # DO NOT CHANGE, unless you want CAPI to follow Redirects.\n  # If you want to disable routes from following redirects\n  disable:\n    redirect: true\n\n  # Websocket Gateway Integration\n  websocket:\n    enabled: true\n    server:\n      host: localhost\n      port: 8382\n  # SSE (Server sent events) Integration    \n  sse:\n    enabled: false\n    server:\n      port: 8383  \n\n  # Traces Integration\n  traces:\n    enabled: false\n    endpoint: http://localhost:9411\n\n  # Consul Integration\n  consul:\n    kv:\n      enabled: false\n      host: http://localhost:8500\n      token: \n      timer:\n        interval: 20000\n    token:\n    hosts:\n      http://localhost:8500\n    discovery:\n      enabled: true\n      timer:\n        interval: 20000\n\n  # Certificate Management\n  # If you want to enable certificate management, please provide a trust store (JKS).\n  trust:\n    store:\n      enabled: false\n      path: /some/context/path/cacerts\n      password: &lt;somepassword&gt;\n      encoded: \n\n  version: ^project.version^\n  name: ^project.name^\n  spring:\n    version: ^project.description^\n\n  gateway:\n    cors:\n      management:\n        enabled: true\n        allowed-headers:\n          Origin,\n          Accept,\n          X-Requested-With,\n          Content-Type,\n          Access-Control-Request-Method,\n          Access-Control-Request-Headers,\n          x-referrer,\n          Authorization,\n          X-Csrf-Request,\n          Cache-Control,\n          pragma,\n          X-Total-Count,\n          Last-Event-ID,\n          X-B3-Sampled,\n          X-B3-SpanId,\n          X-B3-TraceId,\n          X-B3-ParentSpanId,\n          Vary\n\n    # Error handling\n    error:\n      listener:\n        enabled: false\n        context: /capi-error\n        port: 8389\n      endpoint: localhost:8380/capi-error\n      ssl: false\n\n  # oauth2 integration\n  oauth2:\n    cookieName:\n    provider:\n      enabled: true\n      keys: http://host/jwks.json\n\n  # OPA Integration   \n  opa:\n    enabled: false\n    endpoint: http://localhost:8181\n</code></pre>"},{"location":"websocket/","title":"Websocket","text":""},{"location":"websocket/#capi-websocket-support","title":"CAPI Websocket Support.","text":"<p>You can have CAPI acting as a Websocket Gateway. The main features of the Websocket Support are: * Reverse Proxy (Hide your websocket server endpoint) * Authorization (Supports JWT Access tokens) * Load Balancing. (Distribute the traffic to your websocket server nodes)</p> <p>Websocket is disabled by default, to enable, just run CAPI with the following configuration: <pre><code>  websocket:\n    enabled: true\n    server:\n      host: localhost\n      port: 8382      \n</code></pre></p> <p>Make sure that your CAPI instance is running in one of the following modes: Full mode means CAPI will search (Consul) for all type of enabled services: <pre><code>capi:\n   mode: full\n</code></pre> Websocket mode means CAPI will only search (Consul) for websocket services.: <pre><code>capi:\n   mode: websocket\n</code></pre></p> <p>With the following configuration, CAPI will be listening for Websocket requests on localhost port 8382.</p>"},{"location":"websocket/#important-information-regarding-websockets","title":"Important information regarding Websockets.","text":"<p>CAPI will only look into the initial HTTP request, for authorization if needed. After the protocol update, you should manage the connection between your websocket client and your websocket server. If your client or server drops the connection, you will need to start a new request.</p>"},{"location":"websocket/#example-of-a-happy-path-using-an-anonymous-unprotected-web-native-connection-request-to-capi","title":"Example of a happy path using an anonymous (unprotected) web native connection request to CAPI.","text":"<pre><code>websocket: WebSocket | undefined;\nendpoint: string = \"ws://localhost:8381/capi/your-websocket-server/your-version/your-path\";\nthis.websocket = new WebSocket(this.endpoint);\nthis.websocket.onopen = (event: any) =&gt; {\n   console.log(\"Connected to Your Websocket Server via CAPI\");\n}\n</code></pre>"},{"location":"websocket/#example-of-a-happy-path-using-a-protected-web-native-connection-request-to-capi-an-access-token-needs-to-be-sent","title":"Example of a happy path using a protected web native connection request to CAPI. An access token needs to be sent.","text":"<pre><code>websocket: WebSocket | undefined;\nendpoint: string = \"ws://localhost:8381/capi/your-websocket-server/your-version/your-path?access_token=&lt;your JWT access token&gt;\";\nthis.websocket = new WebSocket(this.endpoint);\nthis.websocket.onopen = (event: any) =&gt; {\n   console.log(\"Connected to Your Websocket Server via CAPI\");\n}\n</code></pre>"},{"location":"websocket/#for-authentication-capi-supports-the-standard-authorization-header-or-a-query-parameter-with-the-key-access_token","title":"For authentication CAPI supports the standard Authorization header, or a query parameter with the key <code>access_token</code>.","text":"<p>Important info about Authorization: CAPI actively supports Keycloak as an oauth2 provider, but you should still be able to use any oauth2 compliant provider. See <code>Authorization</code> section to know how CAPI authorizes a request.</p>"},{"location":"websocket/#for-capi-to-know-that-your-api-is-a-websocket-please-set-serviceservicemetatype-to-websocket","title":"For CAPI to know that your API is a Websocket, please set <code>Service.serviceMeta.type</code> to <code>websocket</code>.","text":"<p>(Check Consul Integration)</p>"}]}